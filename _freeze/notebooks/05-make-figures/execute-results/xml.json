{
  "hash": "59b12d24c47c68a9910e69c60221a427",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Evaluate parameters\"\nauthor: Lars Caspersen\neditor: visual\n---\n\n\n\n\n\n\n\n\n\n\n## Aim\n\nRead the estimated model parameters and produce figures for the manuscript. Output will be a bunch of figures including prediction vs observation plots. Boxplots summarizing the model performance in terms of RMSE and RPIQ, as well as plots visualizing the chill and heat submodels in form of temperature response curves.\n\n## Prepare the parameters\n\nFor convenience we convert the parameters in the standard format, that PhenoFlex expects. I wrote a little helper function, that automatically checks which sets of parameters need to be converted and which not.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#|echo: false\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(chillR)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'chillR'\n\nThe following object is masked from 'package:lubridate':\n\n    leap_year\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(LarsChill)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: magrittr\n\nAttaching package: 'magrittr'\n\nThe following object is masked from 'package:purrr':\n\n    set_names\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\npar_all <-read.csv('data/par_all_slim_paper.csv')\n\npar_all$cultivar <- ifelse(par_all$cultivar == 'B\\xfalida', yes = 'Bulida',\n                           no = par_all$cultivar)\n```\n:::\n\n::: {.cell .hidden}\n\n```{.r .cell-code .hidden}\n#| eval: false\n#| include: false\nlibrary(tidyverse)\nlibrary(chillR)\nlibrary(LarsChill)\n#devtools::install_github('larscaspersen/eval_phenoflex')\n\n\n#helper function that converts the parameters of the intermediate format (theta_star, theta_c, pie_c, tau) to the proper format that phenoflex expects (E0, E1, A0, A1)\n\n\nconvert_all_par <- function(par_df){\n  \n  #identify which rows need to be converted\n  conv_i <- which(is.na(par_df$E0) |\n                    is.na(par_df$E1) |\n                    is.na(par_df$A0) |\n                    is.na(par_df$A1)) \n  \n  if(length(conv_i) == 0) return(par_df)\n  \n  par_df_no_conv <- par_df[-conv_i, ]\n  \n  par_conv <- par_df[conv_i,]\n  \n  par_conv <- purrr::map(1:nrow(par_conv), function(i){\n    par <- par_conv[i, LarsChill::phenoflex_parnames_new] %>% \n      unlist() %>% \n      convert_parameters() %>% \n      unname()\n    \n    return(data.frame(E0 = par[5], E1 = par[6], A0 = par[7], A1 = par[8]))\n  }) %>% \n    bind_rows()\n  \n  par_df[conv_i,] %>% \n    select(-E0, -E1, -A0, -A1) %>% \n    cbind(par_conv) %>% \n    rbind(par_df_no_conv) %>% \n    return()\n}\n\n#read model parameters\npar_cherry <- read.csv('data/par-cherry.csv') %>% \n  mutate(species = 'Sweet Cherry') %>% \n  convert_all_par()\n\npar_apricot <- read.csv('data/par-apricot.csv') %>% \n  mutate(species = 'Apricot')%>% \n  convert_all_par()\n\npar_almond <- read.csv('data/par-almond.csv') %>% \n  mutate(species = 'Almond')%>%\n  select(-repetition) %>% \n  convert_all_par()\n\npar_all <- par_almond %>% \n  rbind(par_apricot) %>% \n  rbind(par_cherry)\n\nrm(par_almond, par_apricot, par_cherry)\n\nwrite.csv(par_all, 'data/par_all_slim_paper.csv', row.names = FALSE)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Predict bloom dates for calibration and validation data\n\nNext task is to prepare the temperature data and predict the bloom dates using the different parameter sets. We also need to read the actual observation data for the comparison later.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#compare the prediction accuracy for the different cultivars and models\nmaster_apricot <- read.csv('data/master_apricot.csv') %>% \n  select(species, cultivar, yday, year, split, ncal, location)\nmaster_cherry <- read.csv('data/master_cherry.csv') %>% \n  select(species, cultivar, yday, year, split, ncal, location)\nmaster_almond <- read.csv('data/master_almond.csv') %>% \n  select(species, cultivar, yday, year, split, ncal, location)\n\n#combine the different master files to one grand data.frame\nmaster <- master_almond %>% \n  rbind(master_apricot) %>% \n  rbind(master_cherry) %>% \n  mutate(loc.year = paste(location, year, sep = '.'))\n\nrm(master_almond, master_apricot, master_cherry)\n\n#read temperature data\nsfax <- read.csv('data/sfax.csv')\nmeknes <- read.csv('data/meknes.csv')\nsantomera <- read.csv('data/santomera.csv')\nzaragoza <- read.csv('data/zaragoza_clean.csv')\ncka <- read.csv('data/cka_clean.csv')\ncieza <- read.csv('data/cieza_clean.csv')\n\nweather_list <- list('Meknes' = meknes,\n                     'Santomera' = santomera, \n                     'Sfax' = sfax,\n                     'Zaragoza' = zaragoza,\n                     'Klein-Altendorf' = cka,\n                     'Cieza' = cieza)\n\nstation_list <- read.csv('data/weather_stations.csv', sep = ',', dec = '.')\n\n#generate seasonlist\nseasonlist <- purrr::map2(weather_list, names(weather_list), function(weather, stat){\n  ymin <- min(weather$Year)\n  ymax <- max(weather$Year)\n  \n  weather %>% \n    chillR::stack_hourly_temps(latitude = station_list$lat[station_list$station == stat]) %>% \n    purrr::pluck('hourtemps') %>% \n    chillR::genSeasonList(years = ymin:ymax) %>% \n    setNames(ymin:ymax) %>% \n    return()\n}) %>% \n  unlist(recursive = FALSE)\n\nrm(zaragoza, cieza, cka, meknes, sfax, santomera, station_list, weather_list)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#|echo: false\nmaster$cultivar <- ifelse(master$cultivar == 'B\\xfalida', yes = 'Bulida',\n                           no = master$cultivar)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow we can do the actual bloom prediction. I use the `purrr::map` function, which works similar to a `for` loop or `lapply`, with the extra benefit of being a bit faster and having a convenient loading bar implemented. I iterate over the rows in the parameter data.frame and predict bloom dates for all the respective entries in the `seasonlist`.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| eval: false\n\n#predict bloom dates\npred_out <- purrr::map(1:nrow(par_all), function(i){\n  sub <- master %>% \n    filter(species == par_all$species[i],\n           cultivar == par_all$cultivar[i],\n           ncal == par_all$n_cal[i])\n  \n\n  pred <- par_all[i, LarsChill::phenoflex_parnames_old] %>% \n    unlist() %>% \n    return_predicted_days(modelfn = evalpheno::custom_PhenoFlex_GDHwrapper, SeasonList =   seasonlist[sub$loc.year]) %>% \n    round(digits = 2) \n  \n  data.frame(predicted = pred,\n             species = par_all$species[i],\n             cultivar = par_all$cultivar[i],\n             ncal = par_all$n_cal[i],\n             split = sub$split,\n             location = sub$location,\n             year = sub$year,\n             fit = par_all$fit[i],\n             observed = sub$yday) %>% \n    return()\n}, .progress = TRUE)\n\npred_out <- do.call(rbind, pred_out)\n\nwrite.csv(pred_out, file = 'data/predicted-observed.csv', row.names = FALSE)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Plot RMSE\n\nAt first, let's look for effects of the four variables: `ncal` (calibration dataset size: scarce or full), `fit` (calibration method: single, combined or baseline), `species` (almond, apricot, sweet cherry) and `split`. (calibration, validation). Initially, I was expecting to see that baseline model and combined fit may outperform the single calibration for scarce data set, because they require less parameters. Also, it was commonly suggested, that 10 observations are not sufficient for the single calibration method. That turned out to be not true.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\npred_out <- read.csv('data/predicted-observed.csv')\n\nperf <- pred_out %>% \n  group_by(species, cultivar, fit, split, ncal) %>% \n  summarise(rmse = chillR::RMSEP(predicted, observed))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'species', 'cultivar', 'fit', 'split'. You\ncan override using the `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nggplot(perf, aes(x = species, y = rmse)) +\n  geom_boxplot(aes(fill = fit)) +\n  facet_grid(~ncal)\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-6-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nggplot(perf, aes(x = ncal, y = rmse)) +\n  geom_boxplot(aes(fill = fit)) +\n  facet_grid(~split)\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-7-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nggplot(perf, aes(x = ncal, y = rmse)) +\n  geom_boxplot(aes(fill = fit)) +\n  facet_grid(species~split)\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-8-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#emphasize the difference in calibration and validation\nperf %>% \n  mutate(ncal_plot = factor(ncal, \n                            levels = c('full', 'scarce'),\n                            labels = c('Full Calibration Dataset', 'Scarce Calibration Dataset')),\n         fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  ggplot(aes(x = ncal_plot, y = rmse)) +\n  geom_boxplot(aes(fill = split)) +\n  facet_grid(species~fit_plot) +\n  ylab('Root Mean Square Error (days)') +\n  xlab('Size of Calibration Dataset') +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-9-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNext, I want to check if the difference in calibration and validation differs a lot. This may be an indicator for overfitting. The single-fit data based on the scarce calibration dataset shows signs of overfitting. But it in the plots above we didn't see that the validation performance of single-fit data was worse than in the other treatments. Rather, it seems that the calibration performance of single-fit was just better, but that did not translate into better validation performance.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#table for writing \ntest <- perf %>% \n  group_by(species, ncal, fit, split) %>% \n  summarise(median = median(rmse) %>% round(digits = 1),\n            sd = sd(rmse) %>% round(digits = 1))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'species', 'ncal', 'fit'. You can override\nusing the `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nperf %>% \n  pivot_wider(values_from = rmse, names_from = split) %>% \n  mutate(diff = Validation - Calibration) %>% \n  group_by(ncal, fit) %>% \n  summarise(median = median(diff) %>% round(digits = 1),\n            sd = sd(diff) %>% round(digits = 1))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'ncal'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   ncal [2]\n  ncal   fit      median    sd\n  <chr>  <chr>     <dbl> <dbl>\n1 full   baseline   -0.5   2.5\n2 full   combined    0     1.9\n3 full   single      1.8   2.3\n4 scarce baseline    1.5   2.8\n5 scarce combined    0.9   2.7\n6 scarce single      3.2   3.5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nperf %>% \n  #filter(fit != 'single') %>% \n  pivot_wider(values_from = rmse, names_from = split) %>% \n  mutate(diff = Validation - Calibration) %>% \n  group_by(ncal) %>% \n  summarise(median = median(diff) %>% round(digits = 1),\n            sd = sd(diff) %>% round(digits = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  ncal   median    sd\n  <chr>   <dbl> <dbl>\n1 full      0.4   2.4\n2 scarce    2.1   3.1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNow let's make a more refined plot, suitable for publishing.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#emphasize the difference in fit\np1 <- perf %>% \n  mutate(ncal_plot = factor(ncal, \n                            levels = c('full', 'scarce'),\n                            labels = c('Full Calibration Dataset', 'Scarce Calibration Dataset')),\n         fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  ggplot(aes(x = split, y = rmse)) +\n  geom_boxplot(aes(fill = fit_plot)) +\n  facet_grid(species~ncal_plot) +\n  scale_fill_manual(name = 'Calibration Method', values = c(\"#009E73\", \"#E69F00\", \"#56B4E9\")) +\n  ylab('Root Mean Square Error (days)') +\n  xlab('Data Split') +\n  theme_bw()+\n  theme(legend.position = 'bottom') \n  \n\np1\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-12-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave(filename = 'figures/submission/fig3.tiff', plot = p1, height = 15, width = 15, units = 'cm', device = 'tiff', dpi = 600)\n# ggsave(filename = 'figures/rmse_slim.jpeg', plot = p1, \n#        height = 15, width = 15, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\nI also want to check how much the model performance differed by cultivar.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#check differences in cultivars\np2 <- perf %>% \n  mutate(cultivar = recode(cultivar, \n                           `B\\xfalida` = 'Búlida'),\n    ncal_plot = factor(ncal, \n                            levels = c('full', 'scarce'),\n                            labels = c('Full', 'Scarce')),\n         fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  ggplot(aes(x = cultivar, y = rmse)) +\n  geom_boxplot(aes(fill = fit_plot)) +\n  facet_wrap(species~., scales = 'free_x', ncol = 1, nrow = 3) +\n  scale_fill_manual(name = 'Calibration Method', values = c(\"#009E73\", \"#E69F00\", \"#56B4E9\")) +\n  ylab('Root Mean Square Error (days)') +\n  xlab('Cultivar') +\n  theme_bw()+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        legend.position = 'bottom')\n\np2\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-13-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave(filename = 'figures/rmse_slim_bycultivar.jpeg',plot = p2,\n#        height = 20, width = 15, units = 'cm', device = 'jpeg')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#emphasize the difference full and scarce\nperf %>% \n  mutate(ncal_plot = factor(ncal, \n                            levels = c('full', 'scarce'),\n                            labels = c('Full', 'Scarce')),\n         fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  ggplot(aes(x = split, y = rmse)) +\n  geom_boxplot(aes(fill = ncal_plot)) +\n  facet_grid(species~fit_plot) +\n  ylab('Root Mean Square Error (days)') +\n  xlab('Size of Calibration Dataset') +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-14-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Predicted vs Observed\n\nNext, I want to generate a plot where predicted and observed bloom dates are visualized more explicitly. For that I will need some helper objects that will make plotting easier.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#---------------------------#\n#predicted vs observed plot\n#---------------------------#\n\nstart <- floor(min(c(pred_out$observed, pred_out$predicted)))\nend <- ceiling(max(c(pred_out$observed, pred_out$predicted)))\nthreshold <- 7\nribbon_df <- data.frame(mid = start:end) %>% \n  mutate(lower = mid - threshold,\n         upper = mid + threshold)\n\npred_out <- pred_out %>% \n  mutate(ncal_plot = factor(ncal, \n                            levels = c('full', 'scarce'),\n                            labels = c('Full Calibration Dataset', 'Scarce Calibration Dataset')),\n         fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit')))\n\niqr_df <- pred_out %>% \n  group_by(fit, ncal, fit_plot, ncal_plot) %>% \n  summarise(iqr = IQR(observed))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'fit', 'ncal', 'fit_plot'. You can override\nusing the `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\ntext_df <- pred_out %>% \n  mutate(res = predicted - observed) %>% \n  group_by(split, fit, ncal, fit_plot, ncal_plot) %>% \n  summarise(rmse = chillR::RMSEP(predicted, observed) %>%  round(digits = 1),\n            mean_bias = mean(predicted - observed) %>%  round(digits = 1),\n            n = n(),\n            share_large_res = (sum(abs(res) > threshold) / n()) %>%  round(digits = 2)) %>%  \n  ungroup() %>% \n  merge(iqr_df, by = c('fit', 'ncal', 'fit_plot', 'ncal_plot')) %>% \n  mutate(rpiq = (iqr / rmse) %>%  round(digits = 1)) %>% \n  pivot_longer(cols = c('rmse', 'rpiq', 'mean_bias')) %>% \n  mutate(name.split = paste(name, split, sep= '.')) %>% \n  select(-name, -split, -share_large_res, -iqr, -n) %>% \n  pivot_wider(names_from = name.split)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'split', 'fit', 'ncal', 'fit_plot'. You can\noverride using the `.groups` argument.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\np3 <- pred_out %>% \n  ggplot() +\n  geom_ribbon(data = ribbon_df, aes(x= mid, ymin = lower, ymax = upper), alpha = 0.3) +\n  geom_point(aes(x = observed, y = predicted,\n                 shape = split, col = species, fill = species), size = 2) +\n  geom_abline(slope = 1, intercept = 0, linetype = 'dashed') +\n  geom_text(data = text_df, aes(x = 15, y = 130, \n                label = paste0('Calibration (Validation)\\nRMSE: ',\n                               format(rmse.Calibration, digits = 2),\n                               ' (', format(rmse.Validation, digits = 2), \n                               # ')\\nRPIQ: ',\n                               # format(rpiq.Calibration, digits = 2),\n                               # ' (', format(rpiq.Validation, digits = 2), \n                               ')\\nMean Bias: ',\n                               format(mean_bias.Calibration, digits = 1),\n                               ' (', format(mean_bias.Validation, digits = 1), ')'\n                               )),\n            hjust = 0)+\n  scale_shape_manual(values = c(1, 16),\n                     name = 'Data Split') +\n  scale_color_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n                     name = 'Species')+\n  scale_fill_manual(values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n                    name = 'Species')+\n  scale_x_continuous(breaks = c(1, 32, 60,91, 121, 152), \n                     labels = c('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun')) +\n  scale_y_continuous(breaks = c(1, 32, 60,91, 121, 152), \n                     labels = c('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun')) +\n  facet_grid(ncal_plot~fit_plot) +\n  ylab('Predicted Bloom Date') +\n  xlab('Observed Bloom Date') +\n  theme_bw(base_size = 15)+\n  theme(legend.position = 'bottom')\n\np3\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-16-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave('figures/submission/fig4.tiff', plot = p3,\n#        height = 20, width = 23, units = 'cm', device = 'tiff', dpi = 600)\n# ggsave('figures/pred_obs_slim.jpeg', plot = p3,\n#        height = 20, width = 23, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\nSome more summary tables that I may need for reporting.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ntest <- pred_out %>% \n  mutate(res = predicted - observed) %>% \n  group_by(split, fit, ncal, fit_plot, ncal_plot, species) %>% \n  summarise(rmse = chillR::RMSEP(predicted, observed) %>%  round(digits = 1),\n            mean_bias = mean(predicted - observed) %>%  round(digits = 1),\n            n = n(),\n            share_large_res = (sum(abs(res) > threshold) / n()) %>%  round(digits = 2),\n            nlarge_res = (sum(abs(res) > threshold)) ) %>%  \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'split', 'fit', 'ncal', 'fit_plot',\n'ncal_plot'. You can override using the `.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\npred_out %>% \n  mutate(res = predicted - observed) %>% \n  group_by(split, fit, ncal, fit_plot, ncal_plot) %>% \n  summarise(rmse = chillR::RMSEP(predicted, observed) %>%  round(digits = 1),\n            mean_bias = mean(predicted - observed) %>%  round(digits = 1),\n            n = n(),\n            share_large_res = (sum(abs(res) > threshold) / n()) %>%  round(digits = 2)) %>%  \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'split', 'fit', 'ncal', 'fit_plot'. You can\noverride using the `.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 9\n   split    fit   ncal  fit_plot ncal_plot  rmse mean_bias     n share_large_res\n   <chr>    <chr> <chr> <fct>    <fct>     <dbl>     <dbl> <int>           <dbl>\n 1 Calibra… base… full  Baselin… Full Cal…   6.5       0.1   385            0.25\n 2 Calibra… base… scar… Baselin… Scarce C…   5.4      -0.1   210            0.17\n 3 Calibra… comb… full  Combine… Full Cal…   5.9       0.2   385            0.21\n 4 Calibra… comb… scar… Combine… Scarce C…   4.5       0     210            0.11\n 5 Calibra… sing… full  Cultiva… Full Cal…   4.6      -0.2   385            0.12\n 6 Calibra… sing… scar… Cultiva… Scarce C…   3.6       0     210            0.06\n 7 Validat… base… full  Baselin… Full Cal…   6.5       0.4   139            0.2 \n 8 Validat… base… scar… Baselin… Scarce C…   9.1       2.4   314            0.33\n 9 Validat… comb… full  Combine… Full Cal…   6.6       0.1   139            0.23\n10 Validat… comb… scar… Combine… Scarce C…   7.2       1.5   314            0.25\n11 Validat… sing… full  Cultiva… Full Cal…   6.8       0     139            0.22\n12 Validat… sing… scar… Cultiva… Scarce C…   8.1       1.9   314            0.31\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n## Temperature response plots\n\nWe did not find stark difference in the prediction performance, but we may inspect the parameters themselves. Temperature response curves are a convenient tool the visualize how the parameters translate into the temperature sensitivity of the submodel.\n\nThe LarsChill package has some convenience functions for generating he temperature response curves. It has also some functions to visualize them, but we make our own code for that\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| eval: false\ntemp <- seq(-5, 40, by = 0.1)\n\n\n#make data.fame with temperature response plots\nresponse_df <- purrr::map(1:nrow(par_all), function(i){\n  \n  par_all[i, LarsChill::phenoflex_parnames_old] %>% \n    unlist() %>% \n    LarsChill::get_temp_response_df(temp_values = temp) %>% \n    mutate(species = par_all$species[i],\n           cultivar = par_all$cultivar[i],\n           fit = par_all$fit[i],\n           n_cal = par_all$n_cal[i]) %>% \n    return()\n  \n}, .progress = TRUE) %>% \n  bind_rows()\n\nwrite.csv(response_df, file = 'data/response_df.csv', row.names = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#--------------------------#\n#temperature reaction plots\n#--------------------------#\n\nresponse_df <- read.csv('data/response_df.csv')\n\np4 <- response_df %>% \n  filter(n_cal == 'full') %>% \n  mutate(Heat_response = Heat_response * 40) %>% \n  mutate(fit_plot = factor(fit, \n                    levels = c('baseline', 'single', 'combined'),\n                    labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  pivot_longer(cols = c('Chill_response', 'Heat_response')) %>% \n  mutate(name_plot = factor(name, \n                            levels = c('Chill_response', 'Heat_response'),\n                            labels = c('Chill Response', 'Heat Response'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, name_plot, sep = '_')) %>% \n  ggplot(aes(x = Temperature, y = value, group = id, col = name_plot)) +\n  geom_line(aes(linetype = name_plot), show.legend = FALSE) +\n  scale_y_continuous(\n    \n    # Features of the first axis\n    name = \"Chill Response\",\n    \n    # Add a second axis and specify its features\n    sec.axis = sec_axis( transform=~./40, name=\"Heat Response\")\n  ) +\n  theme_bw(base_size = 15) +\n  scale_color_manual(values = c('#377eb8',  '#e41a1c')) +\n  scale_linetype_manual(values = c('dashed', 'solid')) +\n  facet_grid(species~fit_plot) +\n  theme(\n    # Primary Y-axis (left)\n    axis.text.y.left = element_text(color = '#377eb8'),\n    axis.title.y.left = element_text(color = '#377eb8'),\n    axis.line.y.left = element_line(color = '#377eb8'),\n    \n    # Secondary Y-axis (right)\n    axis.text.y.right = element_text(color = '#e41a1c'),\n    axis.title.y.right = element_text(color = '#e41a1c'),\n    axis.line.y.right = element_line(color = '#e41a1c'),\n      legend.position = 'none'\n    ) \np4\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-19-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave('figures/submission/fig5.tiff',plot = p4, height = 20, width = 25, units = 'cm', device = 'tiff', dpi = 600)\n# ggsave('figures/tempresponse_full.jpeg', plot = p4,height = 20, width = 25, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\nFor the sake of completion, I will also generate the temperature response curve of the scarcity dataset and a combine figure were the curves for both treatments are shown.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| eval: false\np5 <- response_df %>% \n  filter(n_cal == 'scarce') %>% \n  mutate(Heat_response = Heat_response * 40) %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  pivot_longer(cols = c('Chill_response', 'Heat_response')) %>% \n  mutate(name_plot = factor(name, \n                            levels = c('Chill_response', 'Heat_response'),\n                            labels = c('Chill Response', 'Heat Response'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, name_plot, sep = '_')) %>% \n  ggplot(aes(x = Temperature, y = value, group = id, col = name_plot)) +\n  geom_line(aes(linetype = name_plot), show.legend = FALSE) +\n  scale_y_continuous(\n    \n    # Features of the first axis\n    name = \"Chill Response\",\n    \n    # Add a second axis and specify its features\n    sec.axis = sec_axis( transform=~./40, name=\"Heat Response\")\n  ) +\n  theme_bw(base_size = 15) +\n  scale_color_manual(values = c('#377eb8',  '#e41a1c')) +\n  scale_linetype_manual(values = c('dashed', 'solid')) +\n  facet_grid(species~fit_plot) +\n  theme(\n    # Primary Y-axis (left)\n    axis.text.y.left = element_text(color = '#377eb8'),\n    axis.title.y.left = element_text(color = '#377eb8'),\n    axis.line.y.left = element_line(color = '#377eb8'),\n    \n    # Secondary Y-axis (right)\n    axis.text.y.right = element_text(color = '#e41a1c'),\n    axis.title.y.right = element_text(color = '#e41a1c'),\n    axis.line.y.right = element_line(color = '#e41a1c'),\n    legend.position = 'none'\n  ) \n#ggsave('figures/tempresponse_scarce.jpeg', plot = p5,height = 20, width = 25, units = 'cm', device = 'jpeg')\n\n\np6 <- response_df %>% \n  mutate(Heat_response = Heat_response * 40) %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  pivot_longer(cols = c('Chill_response', 'Heat_response')) %>% \n  mutate(name_plot = factor(name, \n                            levels = c('Chill_response', 'Heat_response'),\n                            labels = c('Chill Response', 'Heat Response'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, name_plot, sep = '_')) %>% \n  ggplot(aes(x = Temperature, y = value, group = id, col = name_plot)) +\n  geom_line(aes(linetype = name_plot), show.legend = FALSE) +\n  scale_y_continuous(\n    \n    # Features of the first axis\n    name = \"Chill Response\",\n    \n    # Add a second axis and specify its features\n    sec.axis = sec_axis( transform=~./40, name=\"Heat Response\")\n  ) +\n  theme_bw(base_size = 15) +\n  scale_color_manual(values = c('#377eb8',  '#e41a1c')) +\n  scale_linetype_manual(values = c('dashed', 'solid')) +\n  facet_grid(species~fit_plot) +\n  theme(\n    # Primary Y-axis (left)\n    axis.text.y.left = element_text(color = '#377eb8'),\n    axis.title.y.left = element_text(color = '#377eb8'),\n    axis.line.y.left = element_line(color = '#377eb8'),\n    \n    # Secondary Y-axis (right)\n    axis.text.y.right = element_text(color = '#e41a1c'),\n    axis.title.y.right = element_text(color = '#e41a1c'),\n    axis.line.y.right = element_line(color = '#e41a1c'),\n    legend.position = 'none'\n  ) \n#ggsave('figures/tempresponse_both.jpeg', plot = p6, height = 20, width = 25, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Further evaluations on the model parameters\n\nI decided to also make plots for the cultivar-specific parameters: vc, zc, s1.\n\nFirst, I tried to graph for myself what s1 actually means. The black line is the function representing the share of potential GDH that gets actually accumulated depending on the level of chill accumulation. The idea is, that the more chill is accumulated the more heat can be accumulated. The chill requirement yc (red dashed line) moves the curve left or right. The steepness of the curve is determined by the s1 parameter (blue line). High values of s1 lead to steeper, more step-like transition function. Lower s1 value lead to a more leaning function.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#vizualize also the transition parameters. yc and s1\nget_share_heat <- function(y, yc, s1){\n  sr <- exp(s1 * yc * ((y - yc)/y))\n  return((sr) / (1+sr))\n}\n\ns1 <- 1\nyc <- 40\ny <- 40\n\n\ncurve_df <- purrr::map(1:nrow(par_all), function(i){\n  curve <- get_share_heat(0:100, par_all[i,'yc'], par_all[i,'s1'])\n  return(data.frame(y = 0:100,\n                    yc = par_all[i,'yc'],\n                    s1 = par_all[i,'s1'],\n                    share_heat = curve,\n                    species = par_all$species[i],\n                    cultivar = par_all$cultivar[i],\n                    fit = par_all$fit[i],\n                    n_cal = par_all$n_cal[i]))\n  \n}) \ncurve_df <- do.call('rbind', curve_df)\n\n#calculate the yintercept for the line around the infliction point\nvector_length <- 0.5\nstep_right <- 1\n\ncurve_df %>%    mutate(fit_plot = factor(fit,                             levels = c('baseline', 'single', 'combined'),                            labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>%    mutate(id = paste(species, cultivar, fit, n_cal, sep = '_'),          a = 0.5 - (s1*yc),          x_start = yc-step_right,          x_end = yc+step_right,          y_start = a + s1 *x_start,          y_end = a + s1 * x_end) %>%    mutate(x_vec = x_start - x_end,          y_vec = y_start - y_end,          length = sqrt(x_vec^2 + y_vec^2),          x_einheit = x_vec / length,          y_einheit = y_vec / length,          x_plot_start = yc - (x_einheit*vector_length),          x_plot_end = yc + (x_einheit*vector_length),          y_plot_start = 0.5 - (y_einheit*vector_length),          y_plot_end = 0.5 + (y_einheit * vector_length)) %>%    filter(cultivar == 'Schneiders', fit == 'combined', n_cal == 'full') %>%    ggplot(aes(x = y, y = share_heat, group = id)) +   geom_line(show.legend = FALSE) +   geom_segment(aes(y = 0.5, yend = 0, x = yc, xend = yc), col = 'red',                linetype = 'dashed') +   geom_point(aes(y = 0.5, x = yc), col = 'red',              shape = 4, size = 1) +   geom_segment(aes(y = y_plot_start,                    yend = y_plot_end,                    x = x_plot_start,                    xend = x_plot_end),                col = 'blue') +   theme_bw(base_size = 15) +   ylab('Share of potential heat that gets accumulated') +   ylab('Amount of chill (y) accumulated') \n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-21-1.png)\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nFirst is a plot that depicts how different values in s1 lead to different transition curves.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\ncurve_df %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, sep = '_'),\n         a = 0.5 - (s1*yc),\n         x_start = yc-step_right,\n         x_end = yc+step_right,\n         y_start = a + s1 *x_start,\n         y_end = a + s1 * x_end) %>% \n  mutate(x_vec = x_start - x_end,\n         y_vec = y_start - y_end,\n         length = sqrt(x_vec^2 + y_vec^2),\n         x_einheit = x_vec / length,\n         y_einheit = y_vec / length,\n         x_plot_start = yc - (x_einheit*vector_length),\n         x_plot_end = yc + (x_einheit*vector_length),\n         y_plot_start = 0.5 - (y_einheit*vector_length),\n         y_plot_end = 0.5 + (y_einheit * vector_length)) %>% \n  ggplot(aes(x = y, y = share_heat, group = id)) +\n  geom_line(show.legend = FALSE) +\n  # geom_segment(aes(y = 0.5, yend = 0, x = yc, xend = yc), col = 'red',\n  #              linetype = 'dashed') +\n  # geom_point(aes(y = 0.5, x = yc), col = 'red',\n  #            shape = 4, size = 1) +\n  # geom_segment(aes(y = y_plot_start,\n  #                  yend = y_plot_end,\n  #                  x = x_plot_start,\n  #                  xend = x_plot_end),\n  #              col = 'blue') +\n  theme_bw(base_size = 15) +\n  ylab('Share of potential heat that gets accumulated') +\n  ylab('Amount of chill (y) accumulated') +\n  facet_grid(species~fit_plot)\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-22-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave('figures/vizualize_sigmoidalcurve_s1_yc.jpeg', height = 20, width = 20, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\nSame plot but with color differentiation among the cultivars.\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\np1 <- curve_df %>% \n  filter(species == 'Almond') %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, sep = '_')) %>% \n  ggplot(aes(x = y, y = share_heat, group = id, col = cultivar)) +\n  geom_line(show.legend = FALSE) +\n  theme_bw(base_size = 15) +\n  facet_grid(species~fit_plot) \n\np2 <- curve_df %>% \n  filter(species == 'Apricot') %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, sep = '_')) %>% \n  ggplot(aes(x = y, y = share_heat, group = id, col = cultivar)) +\n  geom_line(show.legend = FALSE) +\n  theme_bw(base_size = 15) +\n  facet_grid(species~fit_plot) \n\np3 <- curve_df %>% \n  filter(species == 'Sweet Cherry') %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>% \n  mutate(id = paste(species, cultivar, fit, n_cal, sep = '_')) %>% \n  ggplot(aes(x = y, y = share_heat, group = id, col = cultivar)) +\n  geom_line(show.legend = FALSE) +\n  theme_bw(base_size = 15) +\n  facet_grid(species~fit_plot) \n\nlibrary(patchwork)\np1/p2/p3\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-23-1.png)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nforce_label <- data.frame(species_label = factor('Almond',\n                                                 levels = c('Almond', 'Apricot', 'Sweet Cherry'),\n                                                 labels = c('Almond', 'Apricot', 'Sweet~Cherry')),\n                          fit_plot = factor('baseline', \n                                            levels = c('baseline', 'single', 'combined'),\n                                            labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit')),\n                          name = factor(c('yc', 'zc', 's1'),\n                                        levels = c('yc', 'zc', 's1'),\n                                        labels = c('y[c]', 'z[c]','s[1]')),\n                          value = rep(0,3))\n\npar_all %>% \n  mutate(fit_plot = factor(fit, \n                           levels = c('baseline', 'single', 'combined'),\n                           labels = c('Baseline Model', 'Cultivar-Fit', 'Combined-Fit'))) %>%\n  pivot_longer(cols = c('yc', 'zc', 's1')) %>% \n  mutate(name = factor(name,\n                       levels = c('yc', 'zc', 's1'),\n                       labels = c('y[c]', 'z[c]','s[1]')),\n         species_grid = factor(species,\n                               levels = c('Almond', 'Apricot', 'Sweet Cherry'),\n                               labels = c('Almond', 'Apricot', 'Sweet~Cherry'))) %>% \n  ggplot(aes(x = fit_plot, y = value, fill = fit_plot)) +\n  geom_boxplot() +\n  geom_point(data = force_label, col = 'white', size = 0.1) +\n  scale_fill_manual(name = 'Calibration Method', values = c(\"#009E73\", \"#E69F00\", \"#56B4E9\")) +\n  facet_grid(name~species_grid, scales ='free_y', labeller = label_parsed) +\n  theme_bw(base_size = 15) +\n  ylab('Estimated Parameter Value') +\n  xlab('Model Calibration Method') +\n  theme(legend.position = 'none')\n```\n\n::: {.cell-output-display}\n![](05-make-figures_files/figure-jats/unnamed-chunk-24-1.png)\n:::\n\n```{.r .cell-code .hidden}\n# ggsave('figures/spread_parameters_slim.jpeg', height = 20, width = 29, units = 'cm', device = 'jpeg')\n```\n:::\n\n\n\n\n\n\n\n\n\n\nSummary table for the input data\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#table for text\nmaster %>% \n  mutate(country = case_when(\n    location == 'Meknes' ~ 'Morocco',\n    location == 'Sfax' ~ 'Tunisia',\n    location %in% c('Zaragoza', 'Cieza', 'Santomera') ~ 'Spain',\n    location == 'Klein-Altendorf' ~ 'Germany'\n  )) %>% \n  filter(ncal == 'full') %>% \n  group_by(species, location, country, cultivar) %>% \n  summarise(`Year Start` =   min(year),\n            `Year End` =  max(year),\n            n = n()) %>% \n  knitr::kable()\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n`summarise()` has grouped output by 'species', 'location', 'country'. You can\noverride using the `.groups` argument.\n```\n\n\n:::\n\n::: {.cell-output-display}\n\n\n|species      |location        |country |cultivar    | Year Start| Year End|  n|\n|:------------|:---------------|:-------|:-----------|----------:|--------:|--:|\n|Almond       |Meknes          |Morocco |Ferragnes   |       1977|     2014| 38|\n|Almond       |Meknes          |Morocco |Marcona     |       1977|     2014| 38|\n|Almond       |Meknes          |Morocco |Tuono       |       1974|     2014| 41|\n|Almond       |Santomera       |Spain   |Achaak      |       1997|     2019| 13|\n|Almond       |Santomera       |Spain   |Desmayo     |       1997|     2022| 21|\n|Almond       |Santomera       |Spain   |Marta       |       2005|     2021| 14|\n|Almond       |Sfax            |Tunisia |Fasciuneddu |       1981|     2015| 22|\n|Almond       |Sfax            |Tunisia |Mazzetto    |       1981|     2015| 22|\n|Almond       |Sfax            |Tunisia |Nonpareil   |       1981|     2016| 23|\n|Apricot      |Cieza           |Spain   |Bulida      |       2003|     2022| 21|\n|Apricot      |Cieza           |Spain   |Dorada      |       2003|     2022| 20|\n|Apricot      |Zaragoza        |Spain   |Goldrich    |       1999|     2021| 21|\n|Apricot      |Zaragoza        |Spain   |Harcot      |       1999|     2022| 22|\n|Apricot      |Zaragoza        |Spain   |Henderson   |       1999|     2021| 21|\n|Apricot      |Zaragoza        |Spain   |Sunglo      |       1999|     2022| 22|\n|Sweet Cherry |Klein-Altendorf |Germany |Burlat      |       1978|     2015| 29|\n|Sweet Cherry |Klein-Altendorf |Germany |Regina      |       1988|     2020| 32|\n|Sweet Cherry |Klein-Altendorf |Germany |Schneiders  |       1984|     2019| 32|\n|Sweet Cherry |Zaragoza        |Spain   |Rainier     |       1991|     2022| 24|\n|Sweet Cherry |Zaragoza        |Spain   |Sam         |       1991|     2022| 24|\n|Sweet Cherry |Zaragoza        |Spain   |Van         |       1991|     2022| 24|\n\n\n:::\n:::\n",
    "supporting": [
      "05-make-figures_files\\figure-jats"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}